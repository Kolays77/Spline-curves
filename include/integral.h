#pragma once
#include "Poly.h"

// TODO add cond (from - to) < EPS => 0

long double EPS = 1e-12;

template<typename T>
using Rational = std::pair<Point<Poly<T>>, Poly<T>>;

const std::vector<long double> POINTS({-0.9997137267734413,
-0.9984919506395958,
-0.9962951347331251,
-0.9931249370374434,
-0.9889843952429918,
-0.983877540706057,
-0.9778093584869183,
-0.9707857757637064,
-0.9628136542558156,
-0.9539007829254917,
-0.944055870136256,
-0.9332885350430795,
-0.921609298145334,
-0.9090295709825297,
-0.895561644970727,
-0.8812186793850184,
-0.8660146884971647,
-0.8499645278795913,
-0.8330838798884008,
-0.8153892383391762,
-0.7968978923903145,
-0.7776279096494955,
-0.7575981185197072,
-0.7368280898020207,
-0.7153381175730564,
-0.693149199355802,
-0.670283015603141,
-0.6467619085141293,
-0.6226088602037078,
-0.5978474702471788,
-0.5725019326213812,
-0.5465970120650941,
-0.520158019881763,
-0.49321078920819095,
-0.465781649773358,
-0.4378974021720315,
-0.40958529167830154,
-0.38087298162462996,
-0.3517885263724217,
-0.32236034390052914,
-0.292617188038472,
-0.2625881203715035,
-0.23230248184497396,
-0.20178986409573602,
-0.17108008053860327,
-0.14020313723611397,
-0.10918920358006111,
-0.07806858281343663,
-0.046871682421591634,
-0.015628984421543084,
0.015628984421543084,
0.046871682421591634,
0.07806858281343663,
0.10918920358006111,
0.14020313723611397,
0.17108008053860327,
0.20178986409573602,
0.23230248184497396,
0.2625881203715035,
0.292617188038472,
0.32236034390052914,
0.3517885263724217,
0.38087298162462996,
0.40958529167830154,
0.4378974021720315,
0.465781649773358,
0.49321078920819095,
0.520158019881763,
0.5465970120650941,
0.5725019326213812,
0.5978474702471788,
0.6226088602037078,
0.6467619085141293,
0.670283015603141,
0.693149199355802,
0.7153381175730564,
0.7368280898020207,
0.7575981185197072,
0.7776279096494955,
0.7968978923903145,
0.8153892383391762,
0.8330838798884008,
0.8499645278795913,
0.8660146884971647,
0.8812186793850184,
0.895561644970727,
0.9090295709825297,
0.921609298145334,
0.9332885350430795,
0.944055870136256,
0.9539007829254917,
0.9628136542558156,
0.9707857757637064,
0.9778093584869183,
0.983877540706057,
0.9889843952429918,
0.9931249370374434,
0.9962951347331251,
0.9984919506395958,
0.9997137267734413
});


const std::vector<long double> WEIGHTS({
0.0007346344905008809,
0.001709392653517807,
0.002683925371554019,
0.003655961201327216,
0.004624450063421818,
0.005588428003865117,
0.00654694845084515,
0.007499073255464816,
0.008443871469668721,
0.009380419653694542,
0.01030780257486916,
0.01122511402318622,
0.012131457662979251,
0.013025947892971715,
0.01390771070371885,
0.014775884527441474,
0.015629621077546098,
0.01646808617614516,
0.017290460568323632,
0.018095940722128407,
0.018883739613374886,
0.01965308749443545,
0.020403232646209593,
0.021133442112527594,
0.02184300241624754,
0.02253122025633626,
0.02319742318525442,
0.023840960265968263,
0.024461202707957153,
0.025057544481579718,
0.025629402910208283,
0.02617621923954582,
0.02669745918357113,
0.02719261344657694,
0.027661198220792507,
0.028102755659101357,
0.028516854322395237,
0.028903089601125278,
0.029261084110638446,
0.029590488059912694,
0.02989097959333295,
0.03016226510516929,
0.030404079526454932,
0.030616186583980524,
0.03079837903115269,
0.030950478850491105,
0.03107233742756666,
0.031163835696210035,
0.03122488425484948,
0.03125542345386349,
0.03125542345386349,
0.03122488425484948,
0.031163835696210035,
0.03107233742756666,
0.030950478850491105,
0.03079837903115269,
0.030616186583980524,
0.030404079526454932,
0.03016226510516929,
0.02989097959333295,
0.029590488059912694,
0.029261084110638446,
0.028903089601125278,
0.028516854322395237,
0.028102755659101357,
0.027661198220792507,
0.02719261344657694,
0.02669745918357113,
0.02617621923954582,
0.025629402910208283,
0.025057544481579718,
0.024461202707957153,
0.023840960265968263,
0.02319742318525442,
0.02253122025633626,
0.02184300241624754,
0.021133442112527594,
0.020403232646209593,
0.01965308749443545,
0.018883739613374886,
0.018095940722128407,
0.017290460568323632,
0.01646808617614516,
0.015629621077546098,
0.014775884527441474,
0.01390771070371885,
0.013025947892971715,
0.012131457662979251,
0.01122511402318622,
0.01030780257486916,
0.009380419653694542,
0.008443871469668721,
0.007499073255464816,
0.00654694845084515,
0.005588428003865117,
0.004624450063421818,
0.003655961201327216,
0.002683925371554019,
0.001709392653517807,
0.0007346344905008809
});


template<typename T>
T Abs(T value) {
    return value < 0 ? -value : value;
}



template<typename T>
std::complex<T> Integral_first_type(std::complex<T> NUM,
                                    std::complex<T> a, int n,  T from,  T to) {
    //if (std::abs(den.eval(to)) < EPS || std::abs( den.eval(from)) < EPS)
    //    throw std::logic_error("Integral does not converge");
    std::complex<T> A(from);
    std::complex<T> B(to);

    if(n == 1)
        return NUM * ( std::log(B - a) - std::log(A - a)) ;
    else {

        return  NUM / std::complex<T>{n-1.} * (std::complex<T>{1.0}/std::pow(A-a, n-1.) - std::complex<T>{1.0}/std::pow(B-a, n-1.));
    }
}

// A / (x + a)
    template<typename T>
T Integral(const Poly<std::complex<T>>& num,
           const Poly<std::complex<T>>& den, int n,  T from,  T to) {
    // integral elementary fractions :
    // (1.1) A/(x+a)
    // (1.2) A/(x+a)^n

    if (from == to) return 0;

    if (num.deg() == 0 && den.deg() == 1)
        return Integral_first_type(num, den, n, from, to);

    return 0;
}

template<typename T>
T numerical_integral(const Poly<T>& poly, T A, T B) {
    // Legendre's quadrature. Need integrate_points.in, integrate_weights.in
    // https://en.wikipedia.org/wiki/Gauss%E2%80%93Legendre_quadrature
    auto points = POINTS;
    auto weights = WEIGHTS;
    int n = points.size();
    T sum = 0.0;
    for (int i = 0; i < n; ++i) {
        sum += weights[i]*poly.At((B-A)*points[i]/2 + (A+B)/2);
    }
    return (B-A)/2.0 * sum;
}

// Length of the parametric curve
template<typename T>
T numerical_integral_lenght(const Poly<T>& x, const Poly<T>& y, T A, T B) {
    // Legendre's quadrature. Need integrate_points.txt, integrate_weights.txt
    // https://en.wikipedia.org/wiki/Gauss%E2%80%93Legendre_quadrature
    auto points = POINTS;
    auto weights = WEIGHTS;
    int n = points.size();
    T sum = 0.0;

    for (int i = 0; i < n; ++i) {
        T t = (B-A)*points[i]/2 + (A+B)/2;
        sum += weights[i] * std::sqrt( std::pow(x.der().At(t),2) +
                                        std::pow(y.der().At(t),2) );
    }
    return (B-A)/2.0 * sum;
}


// integral of a rational function f(t) = num(t)/den(t)
template<typename T>
T numerical_integral(const Poly<T>& num,
                     const Poly<T>& den, T A, T B) {
    // Legendre's quadrature. Need integrate_points.txt , integrate_weights.txt
    // https://en.wikipedia.org/wiki/Gauss%E2%80%93Legendre_quadrature
    auto points  = POINTS;
    auto weights = WEIGHTS;
    int n = points.size();
    T sum = 0.0;
    T x = 0.0;
    for (int i = 0; i < n; ++i) {
        x = T(B-A)*points[i]/2 + T(A+B)/2;
        sum += weights[i]* num.At(x) / den.At(x);
    }
    return (B-A)/2.0 * sum;
}
